// src/contexts/work/work.model.ts 
import mongoose, { Schema, Document, Model } from 'mongoose';

// üì∏ Interface para Fotos 
export interface WorkPhoto {
  url: string;           // URL p√∫blica da foto
  thumbnailUrl?: string; // URL da miniatura (para performance)
  metadata: {
    originalName: string;
    size: number;
    mimeType: string;
    uploadedAt: Date;
    takenAt?: Date;      // Quando a foto foi tirada (EXIF)
    location?: {         // GPS se dispon√≠vel
      latitude: number;
      longitude: number;
    };
    dimensions?: {
      width: number;
      height: number;
    };
  };
}

export interface IWorkSession extends Document {
  // üîó Refer√™ncias
  contract: mongoose.Types.ObjectId;
  worker: mongoose.Types.ObjectId;
  company: mongoose.Types.ObjectId;
  job: mongoose.Types.ObjectId;
  
  // üìç Check-in
  checkIn: {
    timestamp: Date;
    location: string;
    coordinates?: {
      latitude: number;
      longitude: number;
    };
    photos: WorkPhoto[]; 
    notes?: string;
    ipAddress?: string;
  };
  
  // üìç Check-out
  checkOut?: {
    timestamp: Date;
    location: string;
    coordinates?: {
      latitude: number;
      longitude: number;
    };
    photos: WorkPhoto[]; 
    hoursWorked: number;
    completionNotes?: string;
    ipAddress?: string;
  };
  
  // üìä Status e Metadados
  status: 'active' | 'completed' | 'cancelled';
  totalHours?: number;
  breakTime?: number; // minutos de pausa
  
  // üí∞ Informa√ß√µes de Pagamento
  paymentStatus: 'pending' | 'confirmed' | 'processed' | 'paid';
  calculatedAmount?: number;
  
  // ‚ö†Ô∏è Disputas
  dispute?: {
    raisedBy: 'worker' | 'company';
    reason: string;
    raisedAt: Date;
    resolvedAt?: Date;
    resolution?: string;
  };
  
   //  Extens√£o para rotas
  workType: 'single_location' | 'multi_location_route'; 
  routeProgress?: {
    currentLocationIndex: number;
    completedLocations: number;
    totalLocations: number;
    nextScheduledLocation?: number;
    routeStatus: 'not_started' | 'in_progress' | 'completed';
  };
  
  locationSessions?: {
    locationIndex: number;
    locationName: string;
    locationAddress: string;
    checkIn: {
      timestamp: Date;
      photos: WorkPhoto[];
      notes?: string;
      coordinates?: { lat: number; lng: number };
    };
    checkOut?: {
      timestamp: Date;
      photos: WorkPhoto[];
      notes?: string;
      coordinates?: { lat: number; lng: number };
    };
    status: 'pending' | 'in_progress' | 'completed' | 'skipped';
    replacedWith?: { // Para substitui√ß√£o de locais
      originalLocationId?: string;
      newLocation: any;
      reason?: string;
    };
  }[];
  
  // üìÖ Metadados
  workDate: Date; // Data do trabalho (YYYY-MM-DD)
  createdAt: Date;
  updatedAt: Date;
}

// üìã Schema para WorkPhoto (SUB-SCHEMA)
const workPhotoSchema = new Schema<WorkPhoto>({
  url: {
    type: String,
    required: [true, 'URL da foto √© obrigat√≥ria']
  },
  thumbnailUrl: {
    type: String
  },
  metadata: {
    originalName: {
      type: String,
      required: [true, 'Nome original da foto √© obrigat√≥rio']
    },
    size: {
      type: Number,
      required: [true, 'Tamanho da foto √© obrigat√≥rio'],
      min: [0, 'Tamanho n√£o pode ser negativo']
    },
    mimeType: {
      type: String,
      required: [true, 'Tipo MIME √© obrigat√≥rio']
    },
    uploadedAt: {
      type: Date,
      default: Date.now
    },
    takenAt: {
      type: Date
    },
    location: {
      latitude: Number,
      longitude: Number
    },
    dimensions: {
      width: Number,
      height: Number
    }
  }
}, { _id: false });

const workSessionSchema = new Schema<IWorkSession>(
  {
    contract: {
      type: Schema.Types.ObjectId,
      ref: 'Contract',
      required: [true, 'Contrato √© obrigat√≥rio'],
      
    },
    worker: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: [true, 'Worker √© obrigat√≥rio'],
      
    },
    company: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: [true, 'Company √© obrigat√≥ria'],
// index: true (removido - duplicado)
    },
    job: {
      type: Schema.Types.ObjectId,
      ref: 'Job',
      required: [true, 'Job √© obrigat√≥rio'],
// index: true (removido - duplicado)
    },
    
    checkIn: {
      timestamp: {
        type: Date,
        required: [true, 'Timestamp do check-in √© obrigat√≥rio'],
        default: Date.now
      },
      location: {
        type: String,
        required: [true, 'Localiza√ß√£o do check-in √© obrigat√≥ria'],
        trim: true,
        maxlength: [500, 'Localiza√ß√£o n√£o pode exceder 500 caracteres']
      },
      coordinates: {
        latitude: {
          type: Number,
          min: -90,
          max: 90
        },
        longitude: {
          type: Number,
          min: -180,
          max: 180
        }
      },
      photos: [workPhotoSchema], 
      notes: {
        type: String,
        trim: true,
        maxlength: [1000, 'Notas n√£o podem exceder 1000 caracteres']
      },
      ipAddress: {
        type: String,
        trim: true
      }
    },
    
    checkOut: {
      timestamp: {
        type: Date
      },
      location: {
        type: String,
        trim: true,
        maxlength: [500, 'Localiza√ß√£o n√£o pode exceder 500 caracteres']
      },
      coordinates: {
        latitude: {
          type: Number,
          min: -90,
          max: 90
        },
        longitude: {
          type: Number,
          min: -180,
          max: 180
        }
      },
      photos: [workPhotoSchema], 
      hoursWorked: {
        type: Number,
        min: [0.25, 'Horas trabalhadas devem ser pelo menos 15 minutos'],
        max: [24, 'Horas trabalhadas n√£o podem exceder 24 horas']
      },
      completionNotes: {
        type: String,
        trim: true,
        maxlength: [2000, 'Notas de conclus√£o n√£o podem exceder 2000 caracteres']
      },
      ipAddress: {
        type: String,
        trim: true
      }
    },
    
    status: {
      type: String,
      enum: {
        values: ['active', 'completed', 'cancelled'],
        message: 'Status deve ser active, completed ou cancelled'
      },
      default: 'active',
// index: true (removido - duplicado)
    },
    
    totalHours: {
      type: Number,
      min: [0, 'Horas totais n√£o podem ser negativas']
    },
    
    breakTime: {
      type: Number,
      min: [0, 'Tempo de pausa n√£o pode ser negativo'],
      default: 0
    },
    
    paymentStatus: {
      type: String,
      enum: {
        values: ['pending', 'confirmed', 'processed', 'paid'],
        message: 'Status de pagamento inv√°lido'
      },
      default: 'pending'
    },
    
    calculatedAmount: {
      type: Number,
      min: [0, 'Valor calculado n√£o pode ser negativo']
    },
    
    dispute: {
      raisedBy: {
        type: String,
        enum: ['worker', 'company']
      },
      reason: {
        type: String,
        trim: true,
        maxlength: [1000, 'Motivo da disputa n√£o pode exceder 1000 caracteres']
      },
      raisedAt: {
        type: Date
      },
      resolvedAt: {
        type: Date
      },
      resolution: {
        type: String,
        trim: true,
        maxlength: [2000, 'Resolu√ß√£o n√£o pode exceder 2000 caracteres']
      }
    },
    
    workDate: {
      type: Date,
      required: [true, 'Data do trabalho √© obrigat√≥ria'],
// index: true (removido - duplicado)
    }
  },
  {
    timestamps: true,
    toJSON: {
      transform: (doc, ret) => {
        ret.id = ret._id.toString();
        delete ret._id;
        delete ret.__v;
        return ret;
      }
    }
  }
);

// 
const locationSessionSchema = new Schema({
  locationIndex: { type: Number, required: true, min: 0 },
  locationName: { type: String, required: true },
  locationAddress: { type: String, required: true },
  checkIn: {
    timestamp: { type: Date, required: true },
    photos: [workPhotoSchema],
    notes: String,
    coordinates: { lat: Number, lng: Number }
  },
  checkOut: {
    timestamp: Date,
    photos: [workPhotoSchema],
    notes: String,
    coordinates: { lat: Number, lng: Number }
  },
  status: {
    type: String,
    enum: ['pending', 'in_progress', 'completed', 'skipped'],
    default: 'pending'
  },
  replacedWith: {
    originalLocationId: String,
    newLocation: {
      name: String,
      address: String,
      type: String,
      coordinates: { lat: Number, lng: Number }
    },
    reason: String
  }
}, { _id: false });

workSessionSchema.add({
  workType: {
    type: String,
    enum: ['single_location', 'multi_location_route'],
    default: 'single_location'
  },
  routeProgress: {
    currentLocationIndex: { type: Number, default: 0, min: 0 },
    completedLocations: { type: Number, default: 0, min: 0 },
    totalLocations: { type: Number, default: 0, min: 0 },
    nextScheduledLocation: Number,
    routeStatus: {
      type: String,
      enum: ['not_started', 'in_progress', 'completed'],
      default: 'not_started'
    }
  },
  locationSessions: [locationSessionSchema]
});

// üìä Indexes para performance (OTIMIZADOS)
workSessionSchema.index({ contract: 1, workDate: -1 });
workSessionSchema.index({ worker: 1, status: 1 });
workSessionSchema.index({ company: 1, status: 1 });
workSessionSchema.index({ job: 1 });
workSessionSchema.index({ 
  'checkIn.timestamp': 1,
  status: 1 
});
workSessionSchema.index({ 
  createdAt: -1 
});
workSessionSchema.index({
  workDate: 1,
  status: 1,
  paymentStatus: 1
});

// üîÑ Middleware para calcular horas totais e datas
workSessionSchema.pre('save', function(next) {
  // Definir workDate baseado no check-in se n√£o estiver definido
  if (!this.workDate && this.checkIn?.timestamp) {
    const checkInDate = new Date(this.checkIn.timestamp);
    checkInDate.setHours(0, 0, 0, 0);
    this.workDate = checkInDate;
  }
  
  // Calcular horas totais no check-out
  if (this.checkOut && this.checkOut.hoursWorked && !this.totalHours) {
    this.totalHours = this.checkOut.hoursWorked - (this.breakTime || 0) / 60;
    
    // Garantir que horas totais n√£o sejam negativas
    if (this.totalHours < 0) {
      this.totalHours = 0;
    }
  }
  
  next();
});

// üîÑ Middleware para valida√ß√£o de datas
workSessionSchema.pre('save', function(next) {
  if (this.checkOut?.timestamp && this.checkIn?.timestamp) {
    if (this.checkOut.timestamp < this.checkIn.timestamp) {
      return next(new Error('Check-out n√£o pode ser anterior ao check-in'));
    }
  }
  next();
});

export const WorkSession: Model<IWorkSession> = mongoose.model<IWorkSession>('WorkSession', workSessionSchema);